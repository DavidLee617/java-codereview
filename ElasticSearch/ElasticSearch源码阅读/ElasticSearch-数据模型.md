# 数据模型 
## PacificA 算法

Es的数据副本模型基于主从模式,

PacificA 算法 特点
1. 设计了一个通用的,抽象的框架,冰上不会具体特定的算法
2. 配置关系和数据副本分离,Paxos负责管理配置,数据副本策略采取主从模式
3. 将错误检测和配置更新放在数据副本的交互实现,实现去中心化
   
术语:

Replica Group: 一个互为副本的数据集

Configuration: 配置信息中描述了一个副本组都有那些副本,Primary是谁,以及位于那个节点

Configuration Version:配置信息的版本号,每次发生变换时递增 ,CAS

Serial Number: 代表每个写操作的顺序,每个写操作递增,每个主副本维护自己的递增SN

Prepared List: 写操作的准备序列. 存储来自外部请求的列表,按照SN大小排序,向列表中插入的序列号必须等于列表中的最大SN

Committed List: 写操作的提交序列

设计前提:

节点可以失效,对消息延迟的上线不做假设

消息可以丢失乱序,但不可以被篡改,即不存在拜占庭问题

网络分区可以发生,系统时钟可以不同步,但是漂移是有限度的

系统框架 两部分  存储管理和配置管理

存储管理 负责数据的读取和更新 使用多副本方式保证数据的可靠性和可用性

配置管理 对配置信息进行管理,维护所有配置信息的一致性

### 数据副本策略

1. 写请求进入主副本节点,节点为该操作分配SN（序列号）,使用该SN创建UpdateRequest结构,将该结构插入准备列表
2. 主副本节点将携带SN的UpdateRequest发往从副本节点,从节点收到后同样插入preparelist 并且给主副本节点回复ACK
3. 一旦主副本节点受到所有从副本节点的相应,确定该数据已经被正确写入所有的从副本节点,将updateRequest放入commit list,committedlist向前移动
4. 主副本恢复客户端更新成功完成.对于每一个Prepare消息,主副本节点从副本节点发送一个commit通知,告诉它们自己的commited point位置,从副本节点接收到消息后 维护更新commited point 同步


可以创建一个不等式
$commmited_R\in commited_P \in prepared_R$

### 配置管理

全局的配置管理器负责管理所有副本组的配置.节点可以向管理其提出添加\删除副本的请求,每次请求需要附带版本号,只有一致才会被执行,最后给于新的版本号

设计思路 CAS compare and swap

### 错误检测

分布式系统经常存在的问题 网络分区,节点离线等异常.全局的配置管理器维护权威配置信息,其他各节点上的配置信息不一定同步,必须处理旧主副本和新主副本同时存在的情况

PacificA使用租约机制来解决这个问题

主副本定期向其它从副本获取租约.可能产生两种情况:

1. 主副本节点在一定时间(lease period)内未收到从副本节点的租约恢复,主副本节点认为从副本及诶单异常,想配置管理器汇报,将异常从副本组一处,自己降级,不再作为主副本节点.
2. 从副本节点在一定时间(grace period)内未收到主副本节点的租约请求,认为主副本异常,向配置管理器汇报,将主副本从副本组中移除,将自己提升为新的组副本.如果存在多个从副本,则先成功者为新主
   
只要 grace>lease ,租约机制就可以保证主副本回避人已从副本献感知到的租约失效.同事任何一个从副本只有在租约失效时才会争取去当新的主副本.
保证新主产生之前,旧主已经降级.

在ES中
1. Master负责维护索引元信息,类比为配置管理器维护配置信息
2. routing_table存储了所有索引,索引有哪些shard,各自的主分片,以及位于哪个节点等信息,类似副本组
3. SequenceNumber和ckpt 类似PacificA算法中的SN和commited pt

**设计思想 设计哲学 孟德斯鸠 三权分立**

## ES的数据副本类型

索引被拆分为多个分片,并且每个分片都有多个副本,成为replication group, 副本组.
并且在删除或者添加文档的时候,各个副本必须同步.

ES的数据副本基于主备模式,朱芬片是所有索引操作的入口,验证索引操作是否有效,一旦主分片接受一个索引操作,主分片的副分片也会接受该操作

**强一致性**

### 基本写入类型

1. routing参数解析到副本组 -> 基于文档ID
2. 确定副本组 转发操作到分片组的主分片.
3. 主分片验证操作和转发到副分片
4. ES维护一个可以接收该操作的分片的副本列表(in-sync 同步副本列表,由Master节点维护). 
5. in-sync 中的分片,都会保证已成功处理所有的索引和删除操作,并给用户返回ACK
6. 主分片维护不变形,必须复制这些操作列表中的每个副本
   
具体流程如下:

1. 请求到达协调节点,协调节点先验证操作,有错就拒绝该操作.根绝当前集群状态,请求被路由到主分片所在节点
2. 操作在主分片上本地执行,索引更新和删除 ,从而变相验证字段的内容,未通过就拒绝
3. 操作成功执行后,转发操作到in-sync副本组的所有副分片 多个副分片 并行转发
4. 一旦所有的副分片成功执行操作并回复主分片,主分片会吧成功的信息返回给协调节点,协调节点返回给客户端.
   
### 写故障处理

写过程会有很多错误出现 硬盘损坏 节点离线 配置错误等原因, 有错误必须主分片必须汇报

1. 主分片自身错误 ,节点发送消息给Master节点,索引会等待mater节点提升一个副分片为主分片.操作会转发给新的主分片,同时Master会监控节点的健康,并且会主动降级主分片.
2. 执行成功后,副分片上潜在的问错误也需要处理, 原因多变,例如执行错误,网络阻塞 导致无法发送内容. 会导致in-sync 副本组中的一个分片丢失一个即将要想用户确认的操作,主分片会发送一条消息到Master 把有问题的分片从set中移除,
3. 在转发请求到副分片时,主分片会使用副分片来验证它是否是一个活跃的主分片.若因为网络问题或者GC被隔离,在它意识到之前的索引操作,会被副分片拒绝,收到拒绝向应收会访问主节点告知自己被拒绝,把之前的操作转到新的主分片.

没有副分片?

由于索引配置或者所有副分片发生故障,主分片的处理操作未经过分和外部验证,会导致问题,另一方面,主分片节点将副分片节点失效的消息告知主节点,主机诶单知道主分片是唯一可用的副本. 为确保上述情况,主节点不会提升任何其他分片为主节点,且所索引到主分片上的任何操作都不会丢失.由于只有单个数据副本,当物理硬件出问题时可能会丢失数据.

### 基本读取模型

通过id读取是轻量级的 但是聚合查询却是重量级的.

主从模式的好处就是分片副本一直,单个in-sync set中的副本也可以提供服务.当一个读请求被协调节点接受,协调节点负责转发请求到其它相关分片的节点,并整理相应结果发送给客户端.

流程如下:

1. 读请求转发到相关分片,大多数搜索会发送到一个或多个索引,通常需要从多个分片进行读取.
2. 从副本组中选择一个相关分片的活跃副本,可以是主分片或者副分片.默认循环遍历
3. 发送分片级的读请求到被选中的副本
4. 合并结果并给客户端返回,针对id的查找会跳过该步,因为只有一个相关分片

### 读故障处理

当分片不能相应一个读请求时,协调节点会从副本组中选择另一个副本,将请求转发给它.没有可用的分片副本会导致重复的错误.在某些情况下,_search,ES倾向于尽早相应,即便是只有部分结果,也不等待问题被解决.

### 引申含义

**高效读取**

在正常操作下,读操作在相关副本组中只执行一次.只有在出错的时候,才会在同一个分片的不同副本中执行多次.

**在写操作返回应答之前读取**

主分片首先在本地进行索引,然后转发请求,由于主分片已经写成功,因此在并行的读请求中,有可能在写请求返回成功之前就可以读取更新的内容

**默认两副本**

在只有两个副本的情况下,该模型也是可以容错.这与quorum0based的系统相反,其容错的最小副本为3.

### 系统异常

在故障时,可能产生如下情况

**单个分片降低索引速度**

因为每次操作时候主分片会等待所有在in-sync列表中的副本,所以单个缓慢的副本可能降低整个副本组的写速度.当然,单个缓慢的分片也会降低读取速度

**脏读**

从一个被隔离的朱分片进行读取,可能读取到没有经过确认的写操作.因为只有主分片向副分片转发请求,或者向主节点发送请求的时候才会被隔离,此时数据已经在主分片写成功,可以被读取到. **通过定期**ping主节点来降低风险,没有已知的主节点,则拒绝索引操作

## Allocation IDS

对于每个分片都有自己的Allocation ID,同时 集群缘心中有列表维护分片的更新状况.

ES通过在集群中保留多个数据副本的方式提供故障转移功能,当出现网络分区或者节点挂掉,更该操作可能无法在所有副本上完成,此时希望把失败的副本标记出来.

ES的数据副本模型会假定其中一个副本为权威副本,称之为主分片.所有的索引操作写主分片,完成后,朱芬片所在节点会负责把更改转发到备份副本,也就是副分片.如果当前主分片临时或者永久的变为不可用状态,那么另外一个分片就被提升为主分片, 换句话说,**一切以主分片为准**.

### 安全地分配主分片

分片分配就是决定哪个节点应该存储一个活跃分片的过程.分片决策过程在主节点完成,并记录在集群状态中,同时还包含了其他元数据,索引设置和映射.分配决策包含两部分,哪个分片应该分配到那个节点,以及那个粉片作为主分片,哪些作为副分片.主节点广播集群状态到集群的所有节点.

每个节点都会通过检查集群状态来判断分片是否可用.如果被指定为主分片,只需要夹在本地分片副本,使其可以用于搜索.若被指定为副分片,节点首先需要从主分片所在的节点赋值差异数据,单可用副分片不足时,主机诶单也可以将副分片分配到不含任何次分片副本的节点,从而指示这些节点创建主分片的完整副本.

主分片的考量, 集群均衡和其他约束, 主节点必须确保主分片副本有最新数据.引入Allocation ID概念,作为区分不同分片的唯一标识

Allocation ID 主节点在分片分配时指定,由数据节点存储在磁盘中,紧邻实际的数据分片. 主节点负责追踪最新数据副本的自己. 该子集被称为同步分片标识, 存储在集群状态. 存在于所有节点.

Allocation IDs存储在shard级元信息中，每个shard都有自己唯一的Allocation ID,同时集群级元信息中记录了一个被认为是最新shard的Allocation ID集合,称之为in-sync allocation IDs

只有分片的allocation ID在  in-sync allocation IDs 集合中,才有可能被选为主分片.

### 分配标记

在ES中,数据副本和元信息副本使用不同的副本策略.元信息的改变需要在集群层面达成一致.只有在特殊情况下才需要与集群一致层进行交互.在处理些请求时 出现故障,主分片中的一些数据为能传播到所有的分片,如果这些副分片仍然被认为是同步,也可能被选为主分片,结果丢失数据

方法:
让写请求失败,已经写得做回滚处理
确保差异的分片不再被视为同步

这里 ES 选择了写入可用性:主分片所在节点命令主节点将差异分片的Allocation ID从in-sync set中删除.朱芬片所在节点等待主节点删除成功的确认消息,一位置集群一致性已经成功更新,之后才向客户端确认写请求.

```
GET /_cluster/allocation/explain
```

### 不会丢失全部

发生严重灾难时,集群中可能会出现只有陈旧副本可用的情况.ES不会把这些分片自动分配为主分片,集群将持续保持Red状态.

reroute API 提供一个子命令,allocate_state_primary,用于将一个陈旧的分片分配为主分片.使用此命令意味着丢失给定分片副本中缺少的数据.如果同步分片副本只是暂时不可用,则使用此命令意味着丢失同步分片副本中最近更新的数据.

## Serquence ID

写操作先到达主分片，主分片写完后转发到副分片，在转发到副分片之前，增加一个计数器，为每个操作分配一个序列号是很简单的。

### Primary Term 和 Sequence Numbers

第一步是能够区分新旧两种主分片,必须找到一种方法来识别是新旧主分片发过来的操作.根本就是一致性.因此,添加了Primary Terms.由主节点分配,当一个主分片被提升时,Primary Terms递增.然后持久化到集群状态中,从而表示集群主分片,从而表示集群主分片所处的一个版本.

有了Primary Terms 就可以添加计数器,为每一个操作分配一个SN,从而理解发生在主分片节点上的索引操作的特定顺序.

PT:由主节点分配给每个主分片,每个主分片发生变化时递增.这个和Raft中的term概念类似
SN: 标记发生在某个分片上的写操作.由主分片分配,只对写操作分配.假设索引index有两个主分片和一个副分片,index[0]的序列号增加到5,主分片离线,副分片被提升为新的主分片,对于后续的写操作,序列号从6开始递增

操作排序的时间
则为

```java
if(s1.seq<s2.seq)
    return s2.seq-s1.seq
else if(s1.seq==s2.seq &&s1.term <s2.term)
    return s2.seq-s1.seq
```

### 本地及全局检查点

有了PT和SN就有了理论上检测出分片之间差异,并在主分片失效时,重新对齐它们的工具. 旧的主分片就可以恢复为与拥有更高PT值的新主分片一致;从旧主分片中删除新主分片操作历史中不存在的操作,并将缺少的操作所引导旧的主分片

计算量太大 -> 引申出"全局检查点"

全局检查点是所有活跃粉片历史都已对齐的我序列号,所有低于全局检查点的操作都已被处理完毕.

主分片负责推进全局检查点,跟踪副分片上完成的操作来实现.一旦所有副分片已经超出给定序列号,相应的更新全局检查点.副分片会维护一个类似全局检查点的局部变量,称为本地检查点.

全局检查点和本地检查点都在内存中维护,也会保存在每个Lucene提交的元数据中.

### 用于快速恢复

当ES恢复一个分片时,需要保证恢复之后与主分片一致. 对于冷数据来说,synced flush可以快熟验证副分片和主分片是否相同,但对于热数据来说,恢复过程需要从主分片复制整个Lucene分段.

从最后一个全局检查点和translog进行恢复,计算差异范围,避免整段复制.

### version

每个文档都有一个版本号,当文档被修改时版本号递增.ES使用这个version来确保变更以正确顺序执行.

版本号由主分片生成,在将请求转发给副本片时将携带此版本号.

另一个作用是实现乐观锁.